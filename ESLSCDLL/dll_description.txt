Description of DLL functions

project settings for DLL:
to avoid linker error LNK1019
set properties for compiler of DLL
C/C++-> Preprocessor-> Preprocessor Definitions = ;ESLSCDLL_EXPORTS;WINNT
set preferences for compiler of calling program to
Linker-> Input-> Additional Dependencies = ESLSCDLL.LIB


** general message box suppress ** 
by default the DLL sends message boxes on error
if this is not wanted, it can be suppressed by calling: DLLErrMsgBoxOff

				// if msg was turned off, it can be turned on gain by calling this func
void DLLErrMsgBoxOn(void);	// BOARD.C sends error messages on default
void DLLErrMsgBoxOff(void);	//general deactivate of error message boxes



******  List of functions  ***********

DLLdef.: void  DLLAboutDrv(UINT32 arg1);
function: return infos about the PCI board, shows 5 info messages
	can be used to test the communication with the PCI board
input: board number (=1 if one PCI board)
output: none
win1 : version of driver 
win2 : ID =53xx
win3 : length of space0 BAR =0x3f
win4 : vendor ID = EBST
win5 : PCI board version (same as label on PCI board)

DLLdef.: void  DLLActCooling(UINT32 drv, UINT8 on);
function: activates cooling for cooled cameras
input1: board number (=1 if one PCI board)
input2: on (=1 = true)
output: none

DLLdef.: void  DLLActMouse(UINT32 drv);
function: activate mouse (should only be used for single core systems)
input1: board number (=1 if one PCI board)
output: none

DLLdef.: DllAccess void DLLBothSlope(UINT32 drv);
function: set trigger input to pos. & neg. slope
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLCal16Bit(UINT32 drv, UINT32 zadr);
function: starts calibrate cycle for older ADC16061 converter,
not needed for actual 16 bit version
input1: board number (=1 if one PCI board)
input2: zadr = 1, not needed, only if in addressed mode
output: none

DLLdef.: void  DLLCCDDrvExit(UINT32 drv);
function: frees handle and memory -> exit driver
input1: board number (=1 if one PCI board)
output: none

DLLdef.: UINT8 DLLCCDDrvInit(UINT32 drv);
function: initialize the driver, must be called before any other
input1: board number (=1 if one PCI board)
output: is true (not 0) if driver was found

DLLdef.: void  DLLCloseShutter(UINT32 arg1);
function: sets the IFC Bit of Interface for sensors with shutter function
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLClrRead(UINT32 drvno, UINT32 fftlines, UINT32 zadr, UINT32 CCDClrCount);
function: needed to erase all charges after a long pause and overexposure
	reads camera clrcount times and don't keep data.
input1: board number (=1 if one PCI board)
input2: fftlines =0 for most sensors, = number of lines for binning if FFT sensor
input3: zadr = 1, not needed, only if in addressed mode
input4: clrcount : number of reads, depends on sensor
output: none

DLLdef.: void DLLClrShCam(UINT32 drvno, UINT32 zadr);
function: clr for cameras with shutter function
	- only NO FIFO version
input1: board number (=1 if one PCI board)
input2: zadr = 1, only if in addressed mode
output: none

DLLdef.: void  DLLDeactMouse(UINT32 drv);
function: deactivate mouse (should only be used for single core systems)
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLDeinit2dViewer();
function: call when closing 2d viewer or at least before opening a new 2d viewer
output: none

DLLdef.: void  DLLDisableFifo(UINT32 drv);
function: disable FIFO
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLEnableFifo(UINT32 drv);
function: enable FIFO
input1: board number (=1 if one PCI board)
output: none

DLLdef.: UINT8 DLLFFOvl(UINT32 drv);
function: check ovl flag (overflow of FIFO)
	if occured stays active until a call of FFRS
input1: board number (=1 if one PCI board)
output: is true (not 0)if overflow occured

DLLdef.: UINT8 DLLFFValid(UINT32 drv);
function: checks content of FIFO
input1: board number (=1 if one PCI board)
output: is true (not 0) if FIFO keeps >= 1 complete lines

DLLdef.: UINT8 DLLFlagXCKI(UINT32 drv);
function: is high if camera read is active
input1: board number (=1 if one PCI board)
output: is true (not 0) if read is currently active

DLLdef.: void  DLLGETCCD(UINT32 drv, UINT32 *dioden, UINT32 fftlines, int32_t fkt, UINT32 zadr);
function: read camera for NO FIFO version only
	each call reads camera and distance to next read defines exposure time
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: fftlines =0 for most sensors, = number of lines for binning if FFT sensor
input4: fkt = 1 for standard read, others are possible -> C source
input5: zadr = 1, not needed, only if in addressed mode

DLLdef.: void  DLLHighSlope(UINT32 drv);
function: set the external trigger slope to + (PCI Reg CrtlA:D5 -> manual)
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLInitBoard(UINT32 drv, UINT8 sym, UINT8 burst, UINT32 pixel, UINT32 waits, UINT32 flag816, UINT32 pportadr, UINT32 pclk, UINT32 xckdelay);
function: initialize the PCI board, must be called once at the start
input1: board number (=1 if one PCI board)
input2: sym = 0 for FIFO, depends on sensor if NO FIFO
input3: burst = 1 for FIFO, depends on sensor if NO FIFO
input4: pixel = number of all pixel (active + dummy pixel)
input5: waits = depends on sensor, sets the pixel read frequency 
input6: flag816 =1 if AD resolution 12 to 16 bit, =2 if 8bit 
input7: pportadr =0 address if parallel port is used
input8: pclk =0 pixelclock, not used here
input9: xckdelay =3, depends on sensor, sets a delay after xck goes high, =7 for Sony sensors
output: none

DLLdef.:  void DLLInitCDS_AD(UINT32 drvno,UINT8 sha,UINT32 amp,INT32 ofs,UINT32 tigain);
function: initialize the cds converter AD9826 (IL-C6 and TI sensors)
input1: board number (=1 if one PCI board)
input2: sha = 0 for cds function, =1 for normal operation
input3: amp = 0..64 input range of AD converter, max. signal should be set to full scale 65k
input4: ofs = -255..+255 adjusts the zero line, should be set that the line is completely above 0
input5: tigain = only for TI sensors: adjust of the avalanche amplification
output: none
 
DLLdef.: UINT64 DLLInitSysTimer(void)
function: init system timer function
	must be called before DLLTicksTimestamp
input1: none
output: ticks per seconds -> depends on PC, 0: no timer there 

DLLdef.: void  DLLLowSlope(UINT32 drv);
function: set the external trigger slope to - (PCI Reg CrtlA:D5 -> manual)
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLOpenShutter(UINT32 drv);
function: open shutter for sensors with EC (exposure control) / sets IFC signal
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLOutTrigHigh(UINT32 drv);
function: set trigger out(Reg CtrlA:D3) of PCI board. Can be used to control timing issues in software.
	The Reg TOR:D31 must have been set to 1 and D30:D27 to zero to see the signal -> see manual
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLOutTrigLow(UINT32 drv);
function: reset trigger out(Reg CtrlA:D3) of PCI board. Can be used to control timing issues in software.
	The Reg TOR:D31 must have been set to 1 and D30:D27 to zero to see the signal -> see manual
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLOutTrigPulse(UINT32 drv, UINT32 PulseWidth);
function: pulses trigger out(Reg CtrlA:D3) of PCI board. Can be used to control timing issues in software.
	The Reg TOR:D31 must have been set to 1 and D30:D27 to zero to see the signal -> see manual
input1: board number (=1 if one PCI board)
input2: duration of pulse in ms
output: none

DLLdef.: void  DLLPickOneFifoscan(UINT32 drv, uint16_t *pdioden, UINT8 *abbr, UINT8 *space, int32_t fkt);
function: special read sequence for FIFO version only
	fifo timer is running and Fifo is enabled for one read
	data is written to array, Fifo is disabled again
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: abbr = address of bool var, is true (not 0) if ESC was hit
input4: space = address of bool var, is true (not 0) if Space was hit
input5: fkt = 1 for standard read, others are possible -> C source
output: none

DLLdef.: UINT8 DLLReadByteS0(UINT32 drv,UINT8 *data,UINT32 PortOff);
function: read byte (8 bit) from register in space0 of PCI board
input1: board number (=1 if one PCI board)
input2: pointer to where data is stored
input3: PortOff of register (count in bytes)
output: ==0 if error

DLLdef.: void  DLLReadFifo(UINT32 drv, uint16_t *dioden, int32_t fkt);
function: read one line from FIFO (be sure that FFValid is true before calling)
	simplest way to get data 
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: fkt = 1 for standard read, others are possible -> C source
output: none

DLLdef.: UINT8 DLLReadFFCounter(UINT32 drv);
function: reads the line counter (how many lines are in the FIFO)
input1: board number (=1 if one PCI board)
output: number of lines

DLLdef.: void  DLLReadFFLoop(UINT32 drv, UINT32 *dioden, UINT32 fftlines, int32_t fkt, UINT32 zadr, UINT32 nos,
 UINT32 exptus, UINT32 freq, UINT32 threadp, UINT32 clrcnt, int16_t releasems, UINT32 exttrig, UINT32 blocktrigger);
function: only for FIFO version: block read of nos scans 
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: fftlines =0 for most sensors, = number of lines for binning if FFT sensor
input4: fkt = 1 for standard read, others are possible -> C source
input5: zadr = 1, not needed, only if in addressed mode
input6: nos = number of scans
input7: exptus = exposure time in micro sec. If this entry is used, freq must be set to 0
input8: freq = read frequency in Hz. If this entry is used, exptus must be set to 0
input9: threadp = 31, priority of thread (1..31/ 31 is highest -> see manual)
input10: clrcnt = number of reads to clear the sensor before block starts, depends on sensor
input11: releasems = -1, time to release thread in ms (for long exposuretimes), <0 means don't release
input12: exttrig = true (not 0) if external trigger for each scan, 0 else
input13: blocktrigger = true (not 0) if one external trigger starts block of nos scans which run with internal timer
output: none

DLLdef.: UINT8 DLLReadKeyPort(UINT32 drv);
function: read key directly from keyboard without interrupt (only works on PS2 keyboard)
	older function: needed to stop single core high priority threads
input1: board number (=1 if one PCI board)
output: code of pressed key

DLLdef.: UINT8 DLLReadLongIOPort(UINT32 drv,UINT32 *data,UINT32 PortOff)
function: read long (32 bit) from runtime register of PCI board
input1: board number (=1 if one PCI board)
input2: pointer to where data is stored
input3: PortOff of register (count in bytes)
output: ==0 if error

DLLdef.: UINT8 DLLReadLongS0(UINT32 drv,UINT32 *data,UINT32 PortOff)
function: read long (32 bit) from register in space0 of PCI board
input1: board number (=1 if one PCI board)
input2: pointer to where data is stored
input3: PortOff of register (count in bytes)
output: ==0 if error

DLLdef.: void  DLLReadLoop(UINT32 drv, UINT32 *dioden, UINT32 fftlines, int32_t fkt, UINT32 zadr, UINT32 nos, 
	UINT32 exptus, UINT32 freq, UINT32 threadp, UINT32 clrcnt, UINT32 exttrig);
function: only for NO FIFO version: block read of nos scans 
input1: board number (=1 if one PCI board)
input2: pdioden = pointer to data array
input3: fftlines =0 for most sensors, = number of lines for binning if FFT sensor
input4: fkt = 1 for standard read, others are possible -> C source
input5: zadr = 1, not needed, only if in addressed mode
input6: nos = number of scans
input7: exptus = exposure time in micro sec. If this entry is used, freq must be set to 0
input8: freq = read frequency in Hz. If this entry is used, exptus must be set to 0
input9: threadp = 31, priority of thread (1..31/ 31 is highest -> see manual)
input10: clrcnt = number of reads to clear the sensor before block starts, depends on sensor
input11: releasems = -1, time to release thread in ms (for long exposuretimes), <0 means don't release
input12: exttrig = true (not 0) if external trigger for each scan, 0 else
input13: blocktrigger = true (not 0) if one external trigger starts block of nos scans which run with internal timer
output: none

DLLdef.: UINT8 DLLBlockTrig(UINT32 drv, UINT8 ch);
function: reads the binary state of an ext. trigger input
input1: ch=0: PCI in, ch=2: opto1, ch=3: opto2

DLLdef.: void  DLLRSFifo(UINT32 drv);
function: reset FIFO and linecounter
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLRsTOREG(UINT32 drv);
function: reset TOR register
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void DLLRsTOREG(UINT32 drvno);
function: reset TOREG register (is used to set the signal of the O-plug of interface board) -> manual
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void DLLSendFLCAM(UINT32 drvno, UINT8 maddr, UINT8 adaddr, UINT16 data)
function: sends data via fibre link, e.g. used for sending data to ADC (ADS5294)
input1: board number (=1 if one PCI board)
input2: master address for specifying device (2 for ADC)
input3: register address
input4: data
output: none

DLLdef.: void DLLSendFLCAM_DAC(UINT32 drvno, UINT8 ctrl, UINT8 addr, UINT16 data, UINT8 feature)
function: sends data via fibre link to DAC8568
input1: board number (=1 if one PCI board)
input2: 4 control bits
input3: 4 address bits
input4: 16 data bits
input5: 4 feature bits
output: none

DLLdef.: void  DLLSetADAmpRed(UINT32 drv, UINT8 gain);
function: set internal register for amplification of AD9826 (cds converter for sensor ILC6)
	full scale of A/D must be adjusted to full scale of signal 
input1: board number (=1 if one PCI board)
input2: gain 0..64
output: none

DLLdef.: void  DLLSetAD16Default(UINT32 drv, UINT32 res);
function: set AD9826 (cds converter: ILC6) to default values (set fixed in BOARD.C)
input1: board number (=1 if one PCI board)
input2: res =1 is the resolution 16bit
output: none

DLLdef.: void  DLLSetADOff(UINT32 drv, UINT8 ofs, UINT8 pos);
function: set internal register for offset of AD9826 (cds converter for sensor ILC6)
	zero line can be set here 
input1: board number (=1 if one PCI board)
input2: ofs = value 0..255
input3: pos = offset can be positive or negative, is positive if not 0 
output: none

DLLdef.: void  DLLSetDA(UINT32 drv, UINT8 gain, UINT8 ch);
function: set DA converter gain value for EM (electron multipliying) sensor TC253
input1: board number (=1 if one PCI board)
input2: gain = value 0..255 set the multiplying factor
input3: ch = 1  
output: none

DLLdef.: void  DLLSetExtTrig(UINT32 drv);
function: set trigger to extern, if extern trigger should be stopped, switch to internal and stop timer
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLSetIntTrig(UINT32 drv);
function: set trigger to intern
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLSetISFFT(UINT32 drv, UINT8 set);
function: set/reset bit for FFT sensor timing(set Reg TOR:D24 -> manual)
input1: board number (=1 if one PCI board)
input2: if set is true (not 0)-> bit is set, reset else
output: none

DLLdef.: void  DLLSetISPDA(UINT32 drv, UINT8 set);
function: set/reset bit for PDA sensor timing(set Reg TOR:D25 -> manual)
input1: board number (=1 if one PCI board)
input2: if set is true (not 0)-> bit is set, reset else
output: none

DLLdef.: void  DLLSetPDAnotFFT(UINT32 drv, UINT8 set);
function: sets PDA sensor timing(set Reg TOR:D25 -> manual) or FFT
input1: board number (=1 if one PCI board)
input2: if set is true (not 0)-> PDA, FFT else
output: none

DLLdef.: void  DLLSetOvsmpl(UINT32 drv, int32_t zadr);
function: set oversample function - only available for special sensors
input1: board number (=1 if one PCI board)
input2: zadr = 1, not needed, only if in addressed mode
output: none

DLLdef.: void  DLLSetTemp(UINT32 drv, UINT32 level);
function: set temperature level for cooled cameras
input1: board number (=1 if one PCI board)
input2: level 0..7 / 0=off, 7=min -> see cooling manual
output: none

DLLdef.: void DLLSetupDELAY(UINT32 drvno, UINT32 delay);
function: set DELAY register (is used to delay write to FIFO signal) -> manual
input1: board number (=1 if one PCI board)
output: none

DLLdef.:  void DLLSetupHAModule(UINT8 irsingle,UINT32 fftlines);
function: set software to HA Module C8061 or C7041
input1: IR single channel module (=1 for IR Module with 256 pixel)
input2: vertical lines of FFT sensor (=0 for IR)
output: none

DLLdef.: void  DLLSetupVCLK(UINT32 drv, UINT32 lines, UINT8 vfreq);
function: set REG VCLKCTRL for FFT sensors
input1: board number (=1 if one PCI board)
input2: number of vertical lines
input3: vertical clk frequency
output: none

DLLdef.: void  DLLStartTimer(UINT32 drv, UINT32 exptime);
function: start hardware timer
input1: board number (=1 if one PCI board)
input2: exposure time in micro sec
output: none

DLLdef.: void  DLLStopFFTimer(UINT32 drv);
function: stop timer (stop camera read)
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLSWTrig(UINT32 drv);
function: triggers one camera read by calling this function
input1: board number (=1 if one PCI board)
output: none

DLLdef.: UINT8 DLLTempGood(UINT32 drv, UINT32 ch);
function: check status of cooling (temperature good = state of EOI signal)
input1: board number (=1 if one PCI board)
input2: ch=1 for first camera, =2 for 2nd and so on
output: is true (not 0) if temperature is reached and stable

DLLdef.: UINT64 DLLTicksTimestamp(void);
function: reads system timer: read 2x ticks and calculate the difference between the calls
	in microsec with DLLTickstous, init timer by calling DLLInitSysTimer before use.
input1: none
output: act ticks 

DLLdef.: UINT32 DLLTickstous(UINT64 tks);
function: translate ticks to micro seconds
input1: ticks of system timer
output: micro seconds of tks

DLLdef.: void  DLLVOn(UINT32 drv);
function: set amplification to high (IR sensors have switchable amp.), set VON signal
input1: board number (=1 if one PCI board)
output: none

DLLdef.: void  DLLVOff(UINT32 drv);
function: set amplification to low (IR sensors have switchable amp.), reset VON signal
input1: board number (=1 if one PCI board)
output: none

DLLdef.: UINT8 DLLWaitforTelapsed(UINT32 musec);
function: used to get a constant delay, for NO FIFO hires timer 
input1: board number (=1 if one PCI board)
output: is true (not 0) if time elapsed

DLLdef.:  UINT8 DLLWaitforTelapsed(UINT32 musec);
function: uses sys timer to make a precise delay, used for NOFIFO exposuretime generation
input1: micro sec to delay
output: returns 0 on success

DLLdef.: void  DLLWaitTrigger(UINT32 drv, UINT8 ExtTrig, UINT8 *SpaceKey, UINT8 *EscapeKey);
function: wait for trigger (on PCI boards input) or key 
	waittrigger is used for NO FIFO version, key test can always be used 
input1: board number (=1 if one PCI board)
input2: ExtTrig = set true (not 0) for extern trigger, false for internal - then its be used for key test
input3: space = address of bool var, is true (not 0) if Space was hit
input4: abbr = address of bool var, is true (not 0) if ESC was hit
output: none

DLLdef.: UINT8 DLLWriteByteS0(UINT32 drv,UINT8 DataByte, UINT32 PortOff);
function: write byte (8 bit) to register in space0 of PCI board
input1: board number (=1 if one PCI board)
input2: DataByte = byte value to write
input3: PortOff of register (count in bytes)
output: ==0 if error

DLLdef.: UINT8 DLLWriteLongS0(UINT32 drv,UINT32 DataL, UINT32 PortOff);
function: write long (32 bit) to register in space0 of PCI board
input1: board number (=1 if one PCI board)
input2: DataByte = long value to write
input3: PortOff of register (count in bytes)
output: ==0 if error

DLLdef.: UINT8 DLLWriteLongIOPort(UINT32 drv,UINT32 DataL, UINT32 PortOff);
function: write long (32 bit) to register in space0 of PCI board
input1: board number (=1 if one PCI board)
input2: DataByte = long value to write
input3: PortOff of register
output: ==0 if error
 
 

**********************  special functions for software ring buffer  ***********************
**********************  is used for FIFO version and multi core systems  ******************
**********************  -> see example GetRingFF or GetRing2cam          ******************

DLLdef.: void  DLLFetchLastRingLine(uint16_t *dioden);
function: get last scan of ring puffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: pdioden = pointer to data array
output: none

DLLdef.:  UINT32 DLLReadRingCounter(UINT32 drvno);
function: get act counter value of software ring buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1:  board number (=1 if one PCI board)
output: counter value

DLLdef.:  UINT8 DLLReadRingBlock(void* pdioden, INT32 start, INT32 stop);
function: read a range from start to stop relative to actual trigger to user buffer
	special function of RingReadThread (see example RingBlockSel)
input1:  pdioden = pointer to user data array
input2:  start = relative line index to ext. trigger (neg. or zero)
input3:  stop = relative line index to ext. trigger (pos. or zero)
output: =0 if no Error

DLLdef.: void DLLReadRingLine(pArrayT pdioden, UINT32 lno); //read ring buffer line number lno 
function: read line lno of ring buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: board number (=1 if one PCI board)
input2: ringdepth = size of ring buffer
output: none

DLLdef.: UINT8 DLLRingThreadIsOFF(void );
function: check if thread is still running, used for sync threads
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: none
output: is true (not 0) if thread was stopped

DLLdef.: UINT8 DLLRingValid(UINT32 drv);
function: check if counter value is > 0 of ring buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: board number (=1 if one PCI board)

DLLdef.: void  DLLShowNewBitmap(UINT32 drvno, UINT16 cur_nob, UINT16 cam, UINT pixelAmount, UINT nos)
function: update the displayed bitmap
input1: board number
input2: current nob
input3: which camera to display (when camcnt is >1)
input4: pixels of one line
input5: samples in one block
output: none

DLLdef.: void  DLLStart2dViewer(UINT32 drvno, UINT16 cur_nob, UINT16 cam, UINT pixelAmount, UINT nos);
function: start 2d viewer
input1: board number
input2: current nob
input3: which camera to display (when camcnt is >1)
input4: pixels of one line
input5: samples in one block
output: none

DLLdef.: void  DLLStartFetchRingBuf(void );
function: start thread to copy data from ring buffer to display buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: none
output: none

DLLdef.: void  DLLStartRingReadThread(UINT32 drv, UINT32 ringdepth, UINT32 threadp, int16_t releasems);
function: get act counter value of ring buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: board number (=1 if one PCI board)
input2: ringdepth = size of ring buffer
input3: threadp = 31, priority of thread (1..31/ 31 is highest -> see manual)
input4: releasems = -1, time to release thread in ms (for long exposuretimes), <0 means don't release
output: none

DLLdef.: void  DLLStopRingReadThread(void );
function: stop thread to copy data from ring buffer to display buffer, 
	special function of RingReadThread (see example GetRingFF or GetRing2cam)
input1: none
output: none


DLLdef.:  void DLLFreeMemInfo(UINT64 memory_all, UINT64 memory_free)
function: get the free and installed memory info.
input1: none
output: memory_all how much is installed
	memory_free: how much is free




